#include "StdAfx.h"
#include "Graph.h"

#include <Util/HelperClass.h>
#include <ArxHelper/HelperClass.h>

//绘制双线
class DoubleLine
{
public:
	DoubleLine(const AcGePoint3d& spt, const AcGePoint3d& ept, double width)
		: m_spt(spt), m_ept(ept), m_width(width)
	{

	}
	AcDbObjectId draw()
	{
		//计算始端的2个坐标
		AcGePoint3d m_leftStartPt, m_leftEndPt;
		AcGePoint3d m_rightStartPt, m_rightEndPt;
		caclStartPoint(m_leftStartPt, m_rightStartPt);
		//计算末端的2个坐标
		caclEndPoint(m_leftEndPt, m_rightEndPt);
		//绘制2条直线
		AcDbObjectId line1 = ArxDrawHelper::DrawLine( m_leftStartPt, m_leftEndPt );
		AcDbObjectId line2 = ArxDrawHelper::DrawLine( m_rightStartPt, m_rightEndPt );

		//构造group
		AcDbObjectIdArray objIds;
		objIds.append(line1);
		objIds.append(line2);
		//构造临时的组名
		CString name;
		name.Format(_T("巷道%d"), count++);
		AcDbObjectId groupId = ArxGroupHelper::CreateGroup(name, objIds);
		if(!groupId.isNull())
		{
			ArxGroupHelper::ConvertToAnonymousGroup(groupId);
		}
		return groupId;
	}

protected:
	void caclStartPoint( AcGePoint3d& startPt1, AcGePoint3d& startPt2 )
	{
		AcGeVector3d v = m_ept - m_spt;
		v.normalize();

		v.rotateBy( PI * 0.5, AcGeVector3d::kZAxis );
		startPt1 = m_spt + v * m_width * 0.5;

		v.rotateBy( PI, AcGeVector3d::kZAxis );
		startPt2 = m_spt + v * m_width * 0.5;
	}

	void caclEndPoint( AcGePoint3d& endPt1, AcGePoint3d& endPt2 )
	{
		AcGeVector3d v = m_ept - m_spt;
		v.normalize();

		v.rotateBy( PI * 0.5, AcGeVector3d::kZAxis );
		endPt1 = m_ept + v * m_width * 0.5;

		v.rotateBy( PI, AcGeVector3d::kZAxis );
		endPt2 = m_ept + v * m_width * 0.5;
	}

private:
	AcGePoint3d m_spt, m_ept;
	double m_width;
	//静态成员变量，用于统计对象个数
	static int count;
};

int DoubleLine::count = 0;

static AcDbObjectId DrawDoubleLine(const AcGePoint3d& spt, const AcGePoint3d& ept, double width)
{
	DoubleLine line(spt, ept, width);
	return line.draw();
}

Graph::Graph(const cbm::CoalPtr& _coal, const cbm::DesignWorkSurfPtr& _ws, const cbm::DesignTechnologyPtr& _tech)
: coal(_coal), work_surf(_ws), tech(_tech)
{
	left_margin = 20;
	right_margin = 20;
	bottom_margin = 20;
	top_margin = 40;

	//倾向长度和走向长度
	L1 = work_surf->l1, L2 = work_surf->l2;
	//煤层厚度和倾角(弧度)
	thick = coal->thick, angle = DegToRad(coal->dip_angle);
	//工作面巷道的宽度和高度
	w = work_surf->w, h = work_surf->h;
	//底板巷的宽度和高度
	wd = tech->wd, hd = tech->hd;
	//左右上下帮距
	left = tech->left_side, right = tech->right_side;
	top = tech->top_side, bottom = tech->bottom_side;
	//钻场宽度、高度和深度
	ws = tech->ws, hs = tech->hs, ds = tech->ds;
	//岩巷和工作面的水平投影距离、垂距
	h_offset = tech->h_offset, v_offset = tech->v_offset;
	//钻孔半径和抽采半径
	radius = tech->dp*0.5, pore_gap = tech->gp;
	//钻场间距
	site_gap = tech->gs;
}

void Graph::setPoint(const AcGePoint3d& pt)
{
	this->m_basePt = pt;
}

AcGePoint3d Graph::getPoint() const
{
	return this->m_basePt;
}

void Graph::addEnt(const AcDbObjectId& objId)
{
	if(objId.isNull()) return;
	if(ArxUtilHelper::IsEqualType(_T("AcDbGroup"), objId))
	{
		ArxGroupHelper::GetObjectIds(objId, m_ents);
	}
	else if(ArxUtilHelper::IsEqualType(_T("AcDbEntity"), objId))
	{
		m_ents.append(objId);
	}
}

void Graph::subDraw()
{
	drawCoal();
	drawWsTunnel();
	drawRockTunnel();
	drawPores();
	drawSites();
}

void Graph::draw()
{
	ArxDocLockSwitch lock_switch;
	subDraw();
}

void Graph::caclCoalExtent(double& Lc, double& Wc, double& Hc) const
{
	//计算宽度(倾向长度L2+工作面左帮控制范围left+偏移)
	//Lc = (L1 + left + left_margin + right_margin)*cos(angle);
	Lc = L1 + left + left_margin + right_margin;
	Wc = L2 + left + right + bottom_margin + top_margin;
	Hc = thick;
}

AcGePoint3d Graph::caclCoalBasePoint1() const
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(),v1,-1*(left+left_margin),v2,-1*(0.5*L2+left+bottom_margin));
}

AcGePoint3d Graph::caclCoalBasePoint2() const
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(),v1,-1*(left+left_margin),v2,-0.5*thick);;
}

AcGePoint3d Graph::caclCoalBasePoint3() const
{
	double Lc = 0, Wc = 0, Hc = 0;
	caclCoalExtent(Lc, Wc, Hc);

	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(),v1,-0.5*Wc,v2,-0.5*thick);;
}

void Graph::caclPoreExtent( double& Lp, double& Wp, double& Hp ) const
{
	//计算长度(倾向长度L2+工作面左帮控制范围left+偏移)
	//Lp = (L1 + left)*cos(angle);
	Lp = L1 + left;
	Wp = L2 + left + right;
	Hp = 0.5;
}

AcGePoint3d Graph::caclPoreBasePoint1() const
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(), v1, -1*left, v2, -1*(left+0.5*L2));
}

AcGePoint3d Graph::caclPoreBasePoint2() const
{
	double Lp = 0, Wp = 0, Hp = 0;
	caclPoreExtent(Lp, Wp, Hp);
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(), v1, -1*left, v2, 0.5*thick+Hp);
}

AcGePoint3d Graph::caclPoreBasePoint3() const
{
	return getPoint();
}

AcGePoint3d Graph::caclSiteBasePoint1() const
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(), v1, right, v2, h_offset);
}

AcGePoint3d Graph::caclSiteBasePoint2() const
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	return ArxDrawHelper::CaclPt(getPoint(), v1, right, v2, -1*(v_offset+0.5*thick));
}

AcGePoint3d Graph::caclSiteBasePoint3() const
{
	return getPoint();
}

void Graph::tranform(const AcGeMatrix3d& mat)
{
	//变换坐标系
	ArxUcsHelper::TransformEntities(m_ents, mat);
}

PlanGraph::PlanGraph(const cbm::CoalPtr& coal, const cbm::DesignWorkSurfPtr& work_surf, const cbm::DesignTechnologyPtr& tech) : Graph(coal, work_surf, tech)
{
}

//绘制一条巷道上的钻场
void Graph::drawSitesOnTunnel(const AcGePoint3d& spt, const AcGePoint3d& ept, double gap_x, double gap_y, double w, double h, double angle, bool excludeFirst)
{
	AcGePoint3dArray pts;
	ArxDrawHelper::Divide(spt, ept, gap_x, gap_y, pts,false);
	int start = excludeFirst?1:0; // 是否绘制第一个钻场
	for(int i=start;i<pts.length();i++)
	{
		AcDbObjectId siteId = ArxDrawHelper::DrawRect(pts[i], angle, w, h);
		//记录在案
		addEnt(siteId);
	}
}

void PlanGraph::drawSites()
{	
	//扣除右帮
	double Ld = L1 - right;

	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d basePt = caclSiteBasePoint1();
	//绘制钻场
	drawSitesOnTunnel(basePt-v2*L2*0.5, basePt+v1*Ld-v2*0.5*L2, site_gap, -0.5*(hs+wd), ws, hs, 0);
	drawSitesOnTunnel(basePt-v2*L2*0.5, basePt+v2*L2*0.5, site_gap, 0.5*(hs+wd), ws, hs, -PI*0.5);
	drawSitesOnTunnel(basePt+v2*L2*0.5, basePt+v1*Ld+v2*L2*0.5, site_gap, -0.5*(hs+wd), ws, hs, 0);
}

void PlanGraph::drawPores()
{
	if(pore_gap <= 0) return;

	//计算钻孔平面投影范围
	double Lp = 0, Wp = 0, Hp = 0;
	caclPoreExtent(Lp, Wp, Hp);
	//平面图钻孔范围的左下角基点坐标
	AcGePoint3d basePt = caclPoreBasePoint1();

	//绘制钻孔
	AcGePoint3dArray pts;
	ArxDrawHelper::MakeGridWithHole(basePt, Lp, Wp, pore_gap, pore_gap, left+right, 0, left+right, left+right, pts, true);
	for(int i=0;i<pts.length();i++)
	{
		AcDbObjectId poreId = ArxDrawHelper::DrawCircle(pts[i], radius);
		//记录在案
		addEnt(poreId);
	}
}

void PlanGraph::drawRockTunnel()
{
	//扣除偏移的部分
	double Ld = L1 - right;
	
	//绘制底板岩巷
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d basePt = ArxDrawHelper::CaclPt(getPoint(), v1, right, v2, h_offset);
	AcDbObjectId t1 = DrawDoubleLine(basePt-v2*L2*0.5, basePt+v1*Ld-v2*L2*0.5, wd);
	//绘制上区段岩巷
	AcDbObjectId t2 = DrawDoubleLine(basePt+0.5*v2*L2, basePt+v1*Ld+0.5*v2*L2, wd);
	//绘制切眼
	AcDbObjectId t3 = DrawDoubleLine(basePt-v2*L2*0.5, basePt+v2*L2*0.5, wd);
	ArxDrawHelper::DrawMText(basePt+v1*Ld-v2*L2*0.5, 0, _T("底板岩巷"), 10);
	ArxDrawHelper::DrawMText(basePt+v1*Ld+v2*L2*0.5, 0, _T("上区段岩巷"), 10);
	//记录在案
	addEnt(t1);
	addEnt(t2);
	addEnt(t3);
}

void PlanGraph::drawWsTunnel()
{
	//工作面巷道的中点位置作为基点
	AcGePoint3d basePt = getPoint();
	//绘制机巷
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcDbObjectId t1 = DrawDoubleLine(basePt-v2*L2*0.5, basePt+v1*L1-v2*L2*0.5, w);
	//绘制风巷
	AcDbObjectId t2 = DrawDoubleLine(basePt+v2*L2*0.5, basePt+v1*L1+v2*L2*0.5, w);
	//绘制工作面切眼
	AcDbObjectId t3 = DrawDoubleLine(basePt-v2*L2*0.5, basePt+v2*L2*0.5, w);
	ArxDrawHelper::DrawMText(basePt+v1*L1-v2*L2*0.5, 0, _T("待掘机巷"), 10);
	ArxDrawHelper::DrawMText(basePt+v1*L1+v2*L2*0.5, 0, _T("待掘风巷"), 10);
	//记录在案
	addEnt(t1);
	addEnt(t2);
	addEnt(t3);
}

void PlanGraph::drawCoal()
{
	//计算煤层的长宽高
	double Lc = 0, Wc = 0, Hc = 0;
	caclCoalExtent(Lc, Wc, Hc);
	//计算平面图中煤层的左下角基点坐标
	AcGePoint3d basePt = caclCoalBasePoint1();

	//绘制煤层面
	AcDbObjectId coalId = ArxDrawHelper::DrawRect2(basePt, 0, Lc, Wc);
	//记录在案
	addEnt(coalId);
	ArxDrawHelper::MakeAlignedDim(basePt, basePt+AcGeVector3d::kXAxis*Lc, 50, false);
	ArxDrawHelper::MakeAlignedDim(basePt, basePt+AcGeVector3d::kYAxis*Wc, 30, true);
	//附加数据
	if(!coalId.isNull())
	{
		CoalData data;
		data.setDataSource(coalId);
		data.m_name = _T("测试");
		data.m_thick = coal->thick;
		data.m_angle = coal->dip_angle;
		data.m_width = work_surf->l1;
		data.m_height = work_surf->l2;
		data.m_pt = basePt;
		data.update(true);
	}
}

HeadGraph::HeadGraph(const cbm::CoalPtr& coal, const cbm::DesignWorkSurfPtr& work_surf, const cbm::DesignTechnologyPtr& tech) : Graph(coal, work_surf, tech)
{

}

void HeadGraph::drawSites()
{
	//扣除右帮
	double Ld = L1 - right;

	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d basePt = caclSiteBasePoint2();
	//绘制钻场
	drawSitesOnTunnel(basePt, basePt+v1*Ld, site_gap, 0, ws, hs, 0, false);
}

void HeadGraph::drawPores()
{
	//扣除右帮
	double Ld = L1 - right;

	//计算钻孔范围
	double Lp = 0, Wp = 0, Hp = 0;
	caclPoreExtent(Lp, Wp, Hp);

	//计算钻孔在倾向方向的个数
	int nx = ArxDrawHelper::DivideNum(Lp, pore_gap, true);
	//计算钻场的个数
	int nd = ArxDrawHelper::DivideNum(Ld, site_gap, false);

	//第1列钻场(工作面巷道上的布置的钻场)
	int n1 = ArxDrawHelper::DivideNum(left+right, pore_gap, true);
	//每个钻场之间的钻孔个数(倾向方向)
	int dn = ArxDrawHelper::DivideNum(nx, nd, true);
	//第2列钻场
	int n2 = dn + dn/2;

	//建立钻孔和钻场的个数联系
	IntArray nums;
	nums.push_back(n1);
	nums.push_back(n2);
	ArxDrawHelper::Shuffle(nx-n1-n2, nd-2, nums);

	//计算钻孔的基点
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d poreBasePt = caclPoreBasePoint2();

	//依次计算钻场与钻孔的关联
	AcGePoint3d siteBasePt = caclSiteBasePoint2();
	int start = 0;
	for(int i=0;i<nd;i++)
	{
		AcGePoint3d site_pt = siteBasePt + v1*i*site_gap + v2*0;
		int end = start + nums[i];
		for(int j=start;j<end;j++)
		{
			AcGePoint3d pore_pt = poreBasePt + v1*j*pore_gap + v2*0;
			AcDbObjectId poreId = ArxDrawHelper::DrawLine(site_pt, pore_pt);
			//记录在案
			addEnt(poreId);
		}
		start = end;
	}
}

void HeadGraph::drawRockTunnel()
{
	//扣除偏移的部分
	double Ld = L1 - right;

	//绘制底板岩巷
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d basePt = ArxDrawHelper::CaclPt(getPoint(), v1, right, v2, -1*(v_offset+0.5*thick));
	AcDbObjectId t1 = DrawDoubleLine(basePt-v1*ds*0.5, basePt+v1*Ld, wd);
	//记录在案
	addEnt(t1);
}

void HeadGraph::drawWsTunnel()
{

}

void HeadGraph::drawCoal()
{
	double Lc = 0, Wc = 0, Hc = 0;
	caclCoalExtent(Lc, Wc, Hc);
	AcGePoint3d basePt = caclCoalBasePoint2();

	//绘制煤层
	AcDbObjectId coalId = ArxDrawHelper::DrawRect2(basePt, 0, Lc, Hc);
	//记录在案
	addEnt(coalId);
}

DipGraph::DipGraph(const cbm::CoalPtr& coal, const cbm::DesignWorkSurfPtr& work_surf, const cbm::DesignTechnologyPtr& tech) : Graph(coal, work_surf, tech)
{

}

void DipGraph::drawSites()
{

}

void DipGraph::drawPores()
{
	//计算钻孔范围
	double Lp = 0, Wp = 0, Hp = 0;
	caclPoreExtent(Lp, Wp, Hp);

	//计算钻孔在走向方向的个数(只计算在控制范围内的)
	int nx = ArxDrawHelper::DivideNum(left+right, pore_gap, true);

	//计算钻孔的基点
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d poreBasePt1 = ArxDrawHelper::CaclPt(getPoint(), v1, -0.5*Wp, v2, 0.5*thick+Hp);
	AcGePoint3d poreBasePt2 = ArxDrawHelper::CaclPt(getPoint(), v1, 0.5*Wp, v2, 0.5*thick+Hp);

	//计算钻场的基点
	AcGePoint3d rockBasePt = ArxDrawHelper::CaclPt(getPoint(), v1, -1*h_offset, v2, -1*v_offset); //岩巷切眼中点
	AcGePoint3d siteBasePt1 = rockBasePt-v1*L2*0.5; // 上区段岩巷
	AcGePoint3d siteBasePt2 = rockBasePt+v1*L2*0.5; // 底板岩巷

	for(int i=0;i<nx;i++)
	{
		AcGePoint3d pore_pt = poreBasePt1 + v1*i*pore_gap + v2*0; // 从左至右计算
		AcDbObjectId poreId = ArxDrawHelper::DrawLine(siteBasePt1, pore_pt);
		//记录在案
		addEnt(poreId);
	}
	for(int i=0;i<nx;i++)
	{
		AcGePoint3d pore_pt = poreBasePt2 - v1*i*pore_gap + v2*0; // 从右至左计算
		AcDbObjectId poreId = ArxDrawHelper::DrawLine(siteBasePt2, pore_pt);
		//记录在案
		addEnt(poreId);
	}
}

void DipGraph::drawRockTunnel()
{
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	AcGePoint3d basePt = ArxDrawHelper::CaclPt(getPoint(), v1, -1*h_offset, v2, -1*v_offset);
	AcDbObjectId t3 = DrawDoubleLine(basePt-v1*L2*0.5, basePt+v1*L2*0.5, hd); // 底板切眼
	//为了画出来的巷道(矩形)是水平的,特殊处理下(旋转)
	AcDbObjectId t2 = ArxDrawHelper::DrawRect(basePt-v1*L2*0.5, angle, wd, hd); // 上区段岩巷
	AcDbObjectId t1 = ArxDrawHelper::DrawRect(basePt+v1*L2*0.5, angle, wd, hd); // 底板岩巷
	//记录在案
	addEnt(t1);
	addEnt(t2);
	addEnt(t3);
}

void DipGraph::drawWsTunnel()
{
	AcGePoint3d basePt = getPoint();
	AcGeVector3d v1 = AcGeVector3d::kXAxis, v2 = AcGeVector3d::kYAxis;
	//为了画出来的巷道(矩形)是水平的,特殊处理下(旋转)
	AcDbObjectId t1 = ArxDrawHelper::DrawRect(basePt+v1*L2*0.5, angle, w, h); // 待掘机巷
	AcDbObjectId t2 = ArxDrawHelper::DrawRect(basePt-v1*L2*0.5, angle, w, h); // 待掘风巷
	AcDbObjectId t3 = DrawDoubleLine(basePt-v1*L2*0.5, basePt+v1*L2*0.5, h); // 工作面切眼
	//记录在案
	addEnt(t1);
	addEnt(t2);
	addEnt(t3);
}

void DipGraph::drawCoal()
{
	double Lc = 0, Wc = 0, Hc = 0;
	caclCoalExtent(Lc, Wc, Hc);
	AcGePoint3d basePt = caclCoalBasePoint3();

	//绘制煤层
	AcDbObjectId coalId = ArxDrawHelper::DrawRect2(basePt, 0, Wc, Hc);
	//记录在案
	addEnt(coalId);
}

void DipGraph::subDraw()
{
	//建立ucs坐标系
	AcGePoint3d origin = getPoint();
	AcGeVector3d xAxis(AcGeVector3d::kXAxis), yAxis(AcGeVector3d::kYAxis);
	xAxis.rotateBy(-1*angle, AcGeVector3d::kZAxis);
	yAxis.rotateBy(-1*angle, AcGeVector3d::kZAxis);
	//得到ucs变换矩阵
	AcGeMatrix3d mat;
	ArxUcsHelper::MakeTransformMatrix(mat, origin, xAxis, yAxis);

	//由于改变了坐标系,需要将基点设置为原点
	setPoint(AcGePoint3d::kOrigin);

	//调用基类方法绘图图形
	Graph::subDraw();

	//将ucs坐标系下绘制的图形变换到wcs坐标系
	Graph::tranform(mat);
}